import os
from typing import Optional, List, Dict, Any, Tuple

# Nota: Importamos oracledb de forma perezosa para evitar errores si no está instalado

def _import_oracledb():
    try:
        import oracledb  # type: ignore
        return oracledb
    except Exception:
        try:
            import cx_Oracle as oracledb  # type: ignore
            return oracledb
        except Exception:
            return None


class OracleDB:
    """Conector para Oracle usando python-oracledb.
    Usa tabla existente 'accidentes' y crea tablas auxiliares para planes y predicciones.
    """
    def __init__(self, user: str, password: str, dsn: str, wallet_dir: Optional[str] = None, client_lib: Optional[str] = None):
        self.user = user
        self.password = password
        self.dsn = dsn
        # Si no viene wallet_dir por env, intentamos usar ./wallet del proyecto
        if not wallet_dir:
            wallet_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'wallet'))
            if not os.path.isdir(wallet_dir):
                wallet_dir = None
        self.wallet_dir = wallet_dir
        self.client_lib = client_lib
        # Establecer TNS_ADMIN si hay wallet
        if self.wallet_dir and not os.environ.get('TNS_ADMIN'):
            os.environ['TNS_ADMIN'] = self.wallet_dir
        self._oracledb = _import_oracledb()
        self._init_client_if_needed()

    def _init_client_if_needed(self):
        if self._oracledb is None:
            return
        try:
            # Thick mode si se provee wallet/client lib
            if self.wallet_dir or self.client_lib:
                self._oracledb.init_oracle_client(
                    lib_dir=self.client_lib if self.client_lib else None,
                    config_dir=self.wallet_dir if self.wallet_dir else None,
                )
        except Exception as e:
            print(f"⚠️ No se pudo inicializar thick mode Oracle (se usará thin): {e}")

    @classmethod
    def from_env(cls) -> Optional["OracleDB"]:
        user = os.environ.get("ORACLE_USER")
        pwd = os.environ.get("ORACLE_PASSWORD")
        dsn = os.environ.get("ORACLE_DSN")  # host:1521/servicio
        wallet_dir = os.environ.get("ORACLE_WALLET_DIR")  # opcional
        client_lib = os.environ.get("ORACLE_CLIENT_LIB")  # opcional ruta a instant client
        if user and pwd and dsn and _import_oracledb() is not None:
            return cls(user, pwd, dsn, wallet_dir=wallet_dir, client_lib=client_lib)
        return None

    def is_ready(self) -> bool:
        return self._oracledb is not None and all([self.user, self.password, self.dsn])

    def connect(self):
        if not self.is_ready():
            raise RuntimeError("OracleDB no configurada")
        oracledb = self._oracledb
        # En thin mode, pasar config_dir para que tome tnsnames/ssl del wallet
        try:
            is_thin = getattr(oracledb, 'is_thin_mode', None)
            if callable(is_thin) and is_thin() and self.wallet_dir:
                return oracledb.connect(user=self.user, password=self.password, dsn=self.dsn, config_dir=self.wallet_dir)
        except Exception:
            pass
        # Thick mode o sin wallet_dir explícito
        return oracledb.connect(user=self.user, password=self.password, dsn=self.dsn)

    # --- Esquema auxiliar ---
    def ensure_schema(self) -> None:
        if not self.is_ready():
            return
        with self.connect() as con:
            cur = con.cursor()
            # Tabla de planes de acción
            cur.execute(
                """
                BEGIN
                    EXECUTE IMMEDIATE 'CREATE TABLE planes_accion (
                        id_plan NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        ts TIMESTAMP DEFAULT SYSTIMESTAMP,
                        comuna VARCHAR2(200),
                        ubicacion_desc VARCHAR2(1000),
                        causa_comun VARCHAR2(400),
                        indice_severidad NUMBER,
                        titulo VARCHAR2(400),
                        contenido_plan CLOB,
                        fuente VARCHAR2(400)
                    )';
                EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
                """
            )
            # Tabla de predicciones de riesgo
            cur.execute(
                """
                BEGIN
                    EXECUTE IMMEDIATE 'CREATE TABLE predicciones_riesgo (
                        id_pred NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        ts TIMESTAMP DEFAULT SYSTIMESTAMP,
                        lat NUMBER,
                        lon NUMBER,
                        id_accidente NUMBER,
                        lat_encontrada NUMBER,
                        lon_encontrada NUMBER,
                        riesgo_predicho VARCHAR2(100),
                        probabilidad NUMBER,
                        categoria_0_prob NUMBER,
                        categoria_1_prob NUMBER,
                        categoria_2_prob NUMBER,
                        comuna VARCHAR2(200),
                        ubicacion_desc VARCHAR2(1000),
                        causa_comun VARCHAR2(400),
                        indice_severidad NUMBER,
                        cliente_ip VARCHAR2(100)
                    )';
                EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
                """
            )
            con.commit()

    # --- Consultas sobre tabla existente 'accidentes' ---
    def list_comunas(self) -> List[str]:
        if not self.is_ready():
            return []
        with self.connect() as con:
            cur = con.cursor()
            cur.execute("SELECT DISTINCT comuna_nombre FROM accidentes WHERE comuna_nombre IS NOT NULL")
            return sorted([str(r[0]) for r in cur.fetchall() if r[0] is not None])

    def fetch_points(self, comuna: Optional[str], bbox: Optional[Tuple[float, float, float, float]], limit: int = 2000) -> List[Dict[str, Any]]:
        if not self.is_ready():
            return []
        q = ("SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, "
             "gravedad, caus_principal, num_fallecidos, condicion_climatica FROM accidentes")
        conds = []
        params: List[Any] = []
        if comuna:
            conds.append("UPPER(comuna_nombre) = :comuna")
            params.append(comuna.upper())
        if bbox:
            min_lat, max_lat, min_lon, max_lon = bbox
            conds.append("latitud BETWEEN :min_lat AND :max_lat")
            conds.append("longitud BETWEEN :min_lon AND :max_lon")
            params.extend([min_lat, max_lat, min_lon, max_lon])
        if conds:
            q += " WHERE " + " AND ".join(conds)
        q += " FETCH FIRST :limit ROWS ONLY"
        params.append(int(limit))
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(q, params)
            rows = []
            for r in cur.fetchall():
                rows.append({
                    "id_accidente": r[0],
                    "fecha_accidente": r[1],
                    "hora_accidente": r[2],
                    "Latitude": float(r[3]),
                    "Longitude": float(r[4]),
                    "COMUNA": r[5],
                    "tipo_accidente": r[6],
                    "gravedad": r[7],
                    "Causa__CON": r[8],
                    "num_fallecidos": r[9],
                    "condicion_climatica": r[10],
                })
            return rows

    def fetch_nearest_accidente(self, lat: float, lon: float) -> Optional[Dict[str, Any]]:
        """Busca el accidente más cercano usando distancia euclidiana simple (aprox)."""
        if not self.is_ready():
            return None
        # Estrategia: limitar el set con una ventana y luego calcular distancia en Python
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(
                "SELECT id_accidente, latitud, longitud, comuna_nombre, tipo_accidente, gravedad, caus_principal, num_fallecidos, condicion_climatica "
                "FROM accidentes WHERE latitud BETWEEN :minlat AND :maxlat AND longitud BETWEEN :minlon AND :maxlon FETCH FIRST 1000 ROWS ONLY",
                [lat - 0.2, lat + 0.2, lon - 0.2, lon + 0.2]
            )
            candidatos = []
            for r in cur.fetchall():
                candidatos.append({
                    "id_accidente": r[0],
                    "Latitude": float(r[1]),
                    "Longitude": float(r[2]),
                    "COMUNA": r[3],
                    "tipo_accidente": r[4],
                    "gravedad": r[5],
                    "Causa__CON": r[6],
                    "num_fallecidos": r[7],
                    "condicion_climatica": r[8],
                })
        if not candidatos:
            return None
        # Calcular distancia
        import math
        best = None
        best_d = 1e12
        for c in candidatos:
            d = math.sqrt((c["Latitude"] - lat) ** 2 + (c["Longitude"] - lon) ** 2)
            if d < best_d:
                best_d = d
                best = c
        return best

    def stats(self, comuna: Optional[str]) -> Dict[str, Any]:
        if not self.is_ready():
            return {"total": 0, "por_clase": {}, "avg_severidad": None}
        q = "SELECT COUNT(*), AVG(gravedad) FROM accidentes"
        params: List[Any] = []
        if comuna:
            q += " WHERE UPPER(comuna_nombre) = :comuna"
            params.append(comuna.upper())
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(q, params)
            row = cur.fetchone() or [0, None]
            total = int(row[0] or 0)
            avg_sev = float(row[1]) if row[1] is not None else None
        return {"total": total, "por_clase": {}, "avg_severidad": avg_sev}

    # --- Registro de predicciones y planes ---
    def log_prediction(self, record: Dict[str, Any]) -> None:
        if not self.is_ready():
            return
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(
                """
                INSERT INTO predicciones_riesgo (
                    lat, lon, id_accidente, lat_encontrada, lon_encontrada, riesgo_predicho, probabilidad,
                    categoria_0_prob, categoria_1_prob, categoria_2_prob, comuna, ubicacion_desc, causa_comun,
                    indice_severidad, cliente_ip
                ) VALUES (:lat, :lon, :id_accidente, :lat_encontrada, :lon_encontrada, :riesgo_predicho, :probabilidad,
                         :categoria_0_prob, :categoria_1_prob, :categoria_2_prob, :comuna, :ubicacion_desc, :causa_comun,
                         :indice_severidad, :cliente_ip)
                """,
                record,
            )
            con.commit()

    def save_plan(self, record: Dict[str, Any]) -> None:
        if not self.is_ready():
            return
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(
                """
                INSERT INTO planes_accion (
                    comuna, ubicacion_desc, causa_comun, indice_severidad, titulo, contenido_plan, fuente
                ) VALUES (:comuna, :ubicacion_desc, :causa_comun, :indice_severidad, :titulo, :contenido_plan, :fuente)
                """,
                record,
            )
            con.commit()

    def list_planes(self, comuna: Optional[str], causa: Optional[str], limit: int = 100) -> List[Dict[str, Any]]:
        if not self.is_ready():
            return []
        q = "SELECT id_plan, ts, comuna, ubicacion_desc, causa_comun, indice_severidad, titulo, fuente FROM planes_accion"
        conds = []
        params: List[Any] = []
        if comuna:
            conds.append("UPPER(comuna)=:comuna")
            params.append(comuna.upper())
        if causa:
            conds.append("UPPER(causa_comun)=:causa")
            params.append(causa.upper())
        if conds:
            q += " WHERE " + " AND ".join(conds)
        q += " ORDER BY ts DESC FETCH FIRST :limit ROWS ONLY"
        params.append(int(limit))
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(q, params)
            out = []
            for r in cur.fetchall():
                out.append({
                    "id_plan": r[0],
                    "ts": r[1],
                    "comuna": r[2],
                    "ubicacion_desc": r[3],
                    "causa_comun": r[4],
                    "indice_severidad": r[5],
                    "titulo": r[6],
                    "fuente": r[7],
                })
            return out

    def list_predicciones(self, comuna: Optional[str], limit: int = 100) -> List[Dict[str, Any]]:
        if not self.is_ready():
            return []
        q = ("SELECT id_pred, ts, lat, lon, id_accidente, lat_encontrada, lon_encontrada, riesgo_predicho, probabilidad, "
             "comuna, ubicacion_desc, causa_comun, indice_severidad, cliente_ip FROM predicciones_riesgo")
        conds = []
        params: List[Any] = []
        if comuna:
            conds.append("UPPER(comuna)=:comuna")
            params.append(comuna.upper())
        if conds:
            q += " WHERE " + " AND ".join(conds)
        q += " ORDER BY ts DESC FETCH FIRST :limit ROWS ONLY"
        params.append(int(limit))
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(q, params)
            out = []
            for r in cur.fetchall():
                out.append({
                    'id_pred': r[0],
                    'ts': r[1],
                    'lat': r[2],
                    'lon': r[3],
                    'id_accidente': r[4],
                    'lat_encontrada': r[5],
                    'lon_encontrada': r[6],
                    'riesgo_predicho': r[7],
                    'probabilidad': r[8],
                    'comuna': r[9],
                    'ubicacion_desc': r[10],
                    'causa_comun': r[11],
                    'indice_severidad': r[12],
                    'cliente_ip': r[13],
                })
            return out

    def list_accidentes(
        self,
        comuna: Optional[str] = None,
        tipo: Optional[str] = None,
        gravedad_min: Optional[int] = None,
        gravedad_max: Optional[int] = None,
        limit: int = 200,
        offset: int = 0,
    ) -> List[Dict[str, Any]]:
        if not self.is_ready():
            return []
        q = (
            "SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, "
            "gravedad, caus_principal, num_fallecidos, condicion_climatica FROM accidentes"
        )
        conds = []
        params: List[Any] = []
        if comuna:
            conds.append("UPPER(comuna_nombre)=:comuna")
            params.append(comuna.upper())
        if tipo:
            conds.append("UPPER(tipo_accidente)=:tipo")
            params.append(tipo.upper())
        if gravedad_min is not None:
            conds.append("gravedad >= :gmin")
            params.append(int(gravedad_min))
        if gravedad_max is not None:
            conds.append("gravedad <= :gmax")
            params.append(int(gravedad_max))
        if conds:
            q += " WHERE " + " AND ".join(conds)
        q += " OFFSET :offset ROWS FETCH NEXT :limit ROWS ONLY"
        params.extend([int(offset), int(limit)])
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(q, params)
            out: List[Dict[str, Any]] = []
            for r in cur.fetchall():
                out.append({
                    "id_accidente": r[0],
                    "fecha_accidente": r[1],
                    "hora_accidente": r[2],
                    "latitud": float(r[3]) if r[3] is not None else None,
                    "longitud": float(r[4]) if r[4] is not None else None,
                    "comuna_nombre": r[5],
                    "tipo_accidente": r[6],
                    "gravedad": r[7],
                    "caus_principal": r[8],
                    "num_fallecidos": r[9],
                    "condicion_climatica": r[10],
                })
            return out

    def list_near_accidentes(self, lat: float, lon: float, limit: int = 50, window_deg: float = 0.2) -> List[Dict[str, Any]]:
        if not self.is_ready():
            return []
        with self.connect() as con:
            cur = con.cursor()
            cur.execute(
                "SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, gravedad, caus_principal, num_fallecidos, condicion_climatica "
                "FROM accidentes WHERE latitud BETWEEN :minlat AND :maxlat AND longitud BETWEEN :minlon AND :maxlon FETCH FIRST 2000 ROWS ONLY",
                [lat - window_deg, lat + window_deg, lon - window_deg, lon + window_deg]
            )
            rows: List[Dict[str, Any]] = []
            for r in cur.fetchall():
                rows.append({
                    "id_accidente": r[0],
                    "fecha_accidente": r[1],
                    "hora_accidente": r[2],
                    "latitud": float(r[3]) if r[3] is not None else None,
                    "longitud": float(r[4]) if r[4] is not None else None,
                    "comuna_nombre": r[5],
                    "tipo_accidente": r[6],
                    "gravedad": r[7],
                    "caus_principal": r[8],
                    "num_fallecidos": r[9],
                    "condicion_climatica": r[10],
                })
        # Ordenar por distancia
        import math
        rows.sort(key=lambda x: math.sqrt(((x.get("latitud") or 0) - lat) ** 2 + ((x.get("longitud") or 0) - lon) ** 2))
        return rows[: int(limit)]

    def ingest_df(self, df, limit: int = 1000) -> int:
        """Stub de ingestión deshabilitado por seguridad. Implementar solo si se requiere poblar 'accidentes'."""
        raise NotImplementedError("Ingest no implementado; use fuentes oficiales para poblar 'accidentes'.")
