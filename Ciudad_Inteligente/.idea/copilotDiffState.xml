<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# Smart Route Optimizer (FastAPI + Streamlit)&#10;&#10;Proyecto base para el desafío Ciudades Inteligentes.&#10;&#10;Estructura:&#10;- api/main.py: API FastAPI con /predict, /coach, /comunas, /geo/points, /stats, /db/health, /admin/ingest&#10;- api/db.py: Conector opcional a Oracle (SQL Developer) usando python-oracledb&#10;- app/streamlit_app.py: Frontend en Streamlit que consume la API&#10;- kb/fichas.md: Mini base de conocimiento local (RAG)&#10;- requirements.txt: dependencias&#10;&#10;## Requisitos&#10;- Python 3.10+&#10;- (Opcional) Oracle DB accesible; SQL Developer es un cliente, la app usa python-oracledb para conectarse a la BD.&#10;&#10;## Instalación (Windows cmd)&#10;```bat&#10;python -m venv .venv&#10;.venv\Scripts\activate&#10;pip install --upgrade pip&#10;pip install -r requirements.txt&#10;```&#10;&#10;## Variables de Entorno para Oracle (opcional)&#10;Configura estas variables si quieres usar la BD:&#10;- ORACLE_USER=usuario&#10;- ORACLE_PASSWORD=clave&#10;- ORACLE_DSN=host:1521/servicio&#10;&#10;Ejemplo (cmd):&#10;```bat&#10;set ORACLE_USER=hr&#10;set ORACLE_PASSWORD=hrpwd&#10;set ORACLE_DSN=localhost:1521/XEPDB1&#10;```&#10;&#10;## Uso&#10;1) Inicia la API&#10;```bat&#10;python main.py api&#10;```&#10;- http://127.0.0.1:8000&#10;- Salud BD: GET /db/health&#10;- Ingesta CSV→Oracle: POST /admin/ingest?limit=10000&#10;&#10;2) Inicia el Frontend&#10;```bat&#10;python main.py app&#10;```&#10;- http://127.0.0.1:8501&#10;- En la pestaña Geo, explora el mapa con filtros, heatmap/hex y exporta CSV.&#10;&#10;## Cargar Datos y Modelo Reales&#10;Coloca en `datos/`:&#10;- motor_riesgo.joblib&#10;- Siniestros_Maestro_Consolidado_Hackathon.csv&#10;Si no existen, se usa un dataset sintético para la demo.&#10;&#10;Para usar Oracle, puedes ingestar el CSV a la tabla ACCIDENTS_POINTS:&#10;- Primero, configura variables de entorno.&#10;- Luego, llama POST /admin/ingest (usa el CSV cargado en memoria por la API).&#10;&#10;## Endpoints&#10;- GET / → estado&#10;- POST /predict → {lat, lon}&#10;- POST /coach → {comuna, ubicacion_desc, causa_comun, indice_severidad}&#10;- GET /comunas&#10;- GET /geo/points?comuna=...&amp;min_lat=...&amp;max_lat=...&amp;min_lon=...&amp;max_lon=...&amp;include_pred=1&amp;limit=1000&#10;- GET /stats?comuna=...&#10;- GET /db/health&#10;- POST /admin/ingest?limit=...&#10;&#10;## Notas y Troubleshooting&#10;- python-oracledb usa modo thin por defecto; no requiere Instant Client. Si tu DSN exige TLS/Wallet, consulta docs de oracledb.&#10;- Si pydeck no renderiza, revisa la conexión a internet y la consola de Streamlit.&#10;- Si faltan librerías, verifica `pip install -r requirements.txt` sin errores.&#10;- Si tu modelo espera columnas específicas, asegúrate que coincidan con el CSV en datos/." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/db.py" />
              <option name="originalContent" value="import os&#10;from typing import Optional, List, Dict, Any, Tuple&#10;&#10;# Nota: Importamos oracledb de forma perezosa para evitar errores si no está instalado&#10;&#10;def _import_oracledb():&#10;    try:&#10;        import oracledb  # type: ignore&#10;        return oracledb&#10;    except Exception:&#10;        try:&#10;            import cx_Oracle as oracledb  # type: ignore&#10;            return oracledb&#10;        except Exception:&#10;            return None&#10;&#10;&#10;class OracleDB:&#10;    &quot;&quot;&quot;Conector para Oracle usando python-oracledb.&#10;    Usa tabla existente 'accidentes' y crea tablas auxiliares para planes y predicciones.&#10;    &quot;&quot;&quot;&#10;    def __init__(self, user: str, password: str, dsn: str, wallet_dir: Optional[str] = None, client_lib: Optional[str] = None):&#10;        self.user = user&#10;        self.password = password&#10;        self.dsn = dsn&#10;        # Si no viene wallet_dir por env, intentamos usar ./wallet del proyecto&#10;        if not wallet_dir:&#10;            wallet_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'wallet'))&#10;            if not os.path.isdir(wallet_dir):&#10;                wallet_dir = None&#10;        self.wallet_dir = wallet_dir&#10;        self.client_lib = client_lib&#10;        # Establecer TNS_ADMIN si hay wallet&#10;        if self.wallet_dir and not os.environ.get('TNS_ADMIN'):&#10;            os.environ['TNS_ADMIN'] = self.wallet_dir&#10;        self._oracledb = _import_oracledb()&#10;        self._init_client_if_needed()&#10;&#10;    def _init_client_if_needed(self):&#10;        if self._oracledb is None:&#10;            return&#10;        try:&#10;            # Thick mode si se provee wallet/client lib&#10;            if self.wallet_dir or self.client_lib:&#10;                self._oracledb.init_oracle_client(&#10;                    lib_dir=self.client_lib if self.client_lib else None,&#10;                    config_dir=self.wallet_dir if self.wallet_dir else None,&#10;                )&#10;        except Exception as e:&#10;            print(f&quot;⚠️ No se pudo inicializar thick mode Oracle (se usará thin): {e}&quot;)&#10;&#10;    @classmethod&#10;    def from_env(cls) -&gt; Optional[&quot;OracleDB&quot;]:&#10;        user = os.environ.get(&quot;ORACLE_USER&quot;)&#10;        pwd = os.environ.get(&quot;ORACLE_PASSWORD&quot;)&#10;        dsn = os.environ.get(&quot;ORACLE_DSN&quot;)  # host:1521/servicio&#10;        wallet_dir = os.environ.get(&quot;ORACLE_WALLET_DIR&quot;)  # opcional&#10;        client_lib = os.environ.get(&quot;ORACLE_CLIENT_LIB&quot;)  # opcional ruta a instant client&#10;        if user and pwd and dsn and _import_oracledb() is not None:&#10;            return cls(user, pwd, dsn, wallet_dir=wallet_dir, client_lib=client_lib)&#10;        return None&#10;&#10;    def is_ready(self) -&gt; bool:&#10;        return self._oracledb is not None and all([self.user, self.password, self.dsn])&#10;&#10;    def connect(self):&#10;        if not self.is_ready():&#10;            raise RuntimeError(&quot;OracleDB no configurada&quot;)&#10;        oracledb = self._oracledb&#10;        # En thin mode, pasar config_dir para que tome tnsnames/ssl del wallet&#10;        try:&#10;            is_thin = getattr(oracledb, 'is_thin_mode', None)&#10;            if callable(is_thin) and is_thin() and self.wallet_dir:&#10;                return oracledb.connect(user=self.user, password=self.password, dsn=self.dsn, config_dir=self.wallet_dir)&#10;        except Exception:&#10;            pass&#10;        # Thick mode o sin wallet_dir explícito&#10;        return oracledb.connect(user=self.user, password=self.password, dsn=self.dsn)&#10;&#10;    # --- Esquema auxiliar ---&#10;    def ensure_schema(self) -&gt; None:&#10;        if not self.is_ready():&#10;            return&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            # Tabla de planes de acción&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                BEGIN&#10;                    EXECUTE IMMEDIATE 'CREATE TABLE planes_accion (&#10;                        id_plan NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,&#10;                        ts TIMESTAMP DEFAULT SYSTIMESTAMP,&#10;                        comuna VARCHAR2(200),&#10;                        ubicacion_desc VARCHAR2(1000),&#10;                        causa_comun VARCHAR2(400),&#10;                        indice_severidad NUMBER,&#10;                        titulo VARCHAR2(400),&#10;                        contenido_plan CLOB,&#10;                        fuente VARCHAR2(400)&#10;                    )';&#10;                EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;&#10;                &quot;&quot;&quot;&#10;            )&#10;            # Tabla de predicciones de riesgo&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                BEGIN&#10;                    EXECUTE IMMEDIATE 'CREATE TABLE predicciones_riesgo (&#10;                        id_pred NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,&#10;                        ts TIMESTAMP DEFAULT SYSTIMESTAMP,&#10;                        lat NUMBER,&#10;                        lon NUMBER,&#10;                        id_accidente NUMBER,&#10;                        lat_encontrada NUMBER,&#10;                        lon_encontrada NUMBER,&#10;                        riesgo_predicho VARCHAR2(100),&#10;                        probabilidad NUMBER,&#10;                        categoria_0_prob NUMBER,&#10;                        categoria_1_prob NUMBER,&#10;                        categoria_2_prob NUMBER,&#10;                        comuna VARCHAR2(200),&#10;                        ubicacion_desc VARCHAR2(1000),&#10;                        causa_comun VARCHAR2(400),&#10;                        indice_severidad NUMBER,&#10;                        cliente_ip VARCHAR2(100)&#10;                    )';&#10;                EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;&#10;                &quot;&quot;&quot;&#10;            )&#10;            con.commit()&#10;&#10;    # --- Consultas sobre tabla existente 'accidentes' ---&#10;    def list_comunas(self) -&gt; List[str]:&#10;        if not self.is_ready():&#10;            return []&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&quot;SELECT DISTINCT comuna_nombre FROM accidentes WHERE comuna_nombre IS NOT NULL&quot;)&#10;            return sorted([str(r[0]) for r in cur.fetchall() if r[0] is not None])&#10;&#10;    def fetch_points(self, comuna: Optional[str], bbox: Optional[Tuple[float, float, float, float]], limit: int = 2000) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = (&quot;SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, &quot;&#10;             &quot;gravedad, caus_principal, num_fallecidos, condicion_climatica FROM accidentes&quot;)&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna_nombre) = :comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if bbox:&#10;            min_lat, max_lat, min_lon, max_lon = bbox&#10;            conds.append(&quot;latitud BETWEEN :min_lat AND :max_lat&quot;)&#10;            conds.append(&quot;longitud BETWEEN :min_lon AND :max_lon&quot;)&#10;            params.extend([min_lat, max_lat, min_lon, max_lon])&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; FETCH FIRST :limit ROWS ONLY&quot;&#10;        params.append(int(limit))&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            rows = []&#10;            for r in cur.fetchall():&#10;                rows.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;fecha_accidente&quot;: r[1],&#10;                    &quot;hora_accidente&quot;: r[2],&#10;                    &quot;Latitude&quot;: float(r[3]),&#10;                    &quot;Longitude&quot;: float(r[4]),&#10;                    &quot;COMUNA&quot;: r[5],&#10;                    &quot;tipo_accidente&quot;: r[6],&#10;                    &quot;gravedad&quot;: r[7],&#10;                    &quot;Causa__CON&quot;: r[8],&#10;                    &quot;num_fallecidos&quot;: r[9],&#10;                    &quot;condicion_climatica&quot;: r[10],&#10;                })&#10;            return rows&#10;&#10;    def fetch_nearest_accidente(self, lat: float, lon: float) -&gt; Optional[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Busca el accidente más cercano usando distancia euclidiana simple (aprox).&quot;&quot;&quot;&#10;        if not self.is_ready():&#10;            return None&#10;        # Estrategia: limitar el set con una ventana y luego calcular distancia en Python&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;SELECT id_accidente, latitud, longitud, comuna_nombre, tipo_accidente, gravedad, caus_principal, num_fallecidos, condicion_climatica &quot;&#10;                &quot;FROM accidentes WHERE latitud BETWEEN :minlat AND :maxlat AND longitud BETWEEN :minlon AND :maxlon FETCH FIRST 1000 ROWS ONLY&quot;,&#10;                [lat - 0.2, lat + 0.2, lon - 0.2, lon + 0.2]&#10;            )&#10;            candidatos = []&#10;            for r in cur.fetchall():&#10;                candidatos.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;Latitude&quot;: float(r[1]),&#10;                    &quot;Longitude&quot;: float(r[2]),&#10;                    &quot;COMUNA&quot;: r[3],&#10;                    &quot;tipo_accidente&quot;: r[4],&#10;                    &quot;gravedad&quot;: r[5],&#10;                    &quot;Causa__CON&quot;: r[6],&#10;                    &quot;num_fallecidos&quot;: r[7],&#10;                    &quot;condicion_climatica&quot;: r[8],&#10;                })&#10;        if not candidatos:&#10;            return None&#10;        # Calcular distancia&#10;        import math&#10;        best = None&#10;        best_d = 1e12&#10;        for c in candidatos:&#10;            d = math.sqrt((c[&quot;Latitude&quot;] - lat) ** 2 + (c[&quot;Longitude&quot;] - lon) ** 2)&#10;            if d &lt; best_d:&#10;                best_d = d&#10;                best = c&#10;        return best&#10;&#10;    def stats(self, comuna: Optional[str]) -&gt; Dict[str, Any]:&#10;        if not self.is_ready():&#10;            return {&quot;total&quot;: 0, &quot;por_clase&quot;: {}, &quot;avg_severidad&quot;: None}&#10;        q = &quot;SELECT COUNT(*), AVG(gravedad) FROM accidentes&quot;&#10;        params: List[Any] = []&#10;        if comuna:&#10;            q += &quot; WHERE UPPER(comuna_nombre) = :comuna&quot;&#10;            params.append(comuna.upper())&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            row = cur.fetchone() or [0, None]&#10;            total = int(row[0] or 0)&#10;            avg_sev = float(row[1]) if row[1] is not None else None&#10;        return {&quot;total&quot;: total, &quot;por_clase&quot;: {}, &quot;avg_severidad&quot;: avg_sev}&#10;&#10;    # --- Registro de predicciones y planes ---&#10;    def log_prediction(self, record: Dict[str, Any]) -&gt; None:&#10;        if not self.is_ready():&#10;            return&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                INSERT INTO predicciones_riesgo (&#10;                    lat, lon, id_accidente, lat_encontrada, lon_encontrada, riesgo_predicho, probabilidad,&#10;                    categoria_0_prob, categoria_1_prob, categoria_2_prob, comuna, ubicacion_desc, causa_comun,&#10;                    indice_severidad, cliente_ip&#10;                ) VALUES (:lat, :lon, :id_accidente, :lat_encontrada, :lon_encontrada, :riesgo_predicho, :probabilidad,&#10;                         :categoria_0_prob, :categoria_1_prob, :categoria_2_prob, :comuna, :ubicacion_desc, :causa_comun,&#10;                         :indice_severidad, :cliente_ip)&#10;                &quot;&quot;&quot;,&#10;                record,&#10;            )&#10;            con.commit()&#10;&#10;    def save_plan(self, record: Dict[str, Any]) -&gt; None:&#10;        if not self.is_ready():&#10;            return&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                INSERT INTO planes_accion (&#10;                    comuna, ubicacion_desc, causa_comun, indice_severidad, titulo, contenido_plan, fuente&#10;                ) VALUES (:comuna, :ubicacion_desc, :causa_comun, :indice_severidad, :titulo, :contenido_plan, :fuente)&#10;                &quot;&quot;&quot;,&#10;                record,&#10;            )&#10;            con.commit()&#10;&#10;    def list_planes(self, comuna: Optional[str], causa: Optional[str], limit: int = 100) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = &quot;SELECT id_plan, ts, comuna, ubicacion_desc, causa_comun, indice_severidad, titulo, fuente FROM planes_accion&quot;&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna)=:comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if causa:&#10;            conds.append(&quot;UPPER(causa_comun)=:causa&quot;)&#10;            params.append(causa.upper())&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; ORDER BY ts DESC FETCH FIRST :limit ROWS ONLY&quot;&#10;        params.append(int(limit))&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            out = []&#10;            for r in cur.fetchall():&#10;                out.append({&#10;                    &quot;id_plan&quot;: r[0],&#10;                    &quot;ts&quot;: r[1],&#10;                    &quot;comuna&quot;: r[2],&#10;                    &quot;ubicacion_desc&quot;: r[3],&#10;                    &quot;causa_comun&quot;: r[4],&#10;                    &quot;indice_severidad&quot;: r[5],&#10;                    &quot;titulo&quot;: r[6],&#10;                    &quot;fuente&quot;: r[7],&#10;                })&#10;            return out&#10;&#10;    def list_predicciones(self, comuna: Optional[str], limit: int = 100) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = (&quot;SELECT id_pred, ts, lat, lon, id_accidente, lat_encontrada, lon_encontrada, riesgo_predicho, probabilidad, &quot;&#10;             &quot;comuna, ubicacion_desc, causa_comun, indice_severidad, cliente_ip FROM predicciones_riesgo&quot;)&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna)=:comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; ORDER BY ts DESC FETCH FIRST :limit ROWS ONLY&quot;&#10;        params.append(int(limit))&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            out = []&#10;            for r in cur.fetchall():&#10;                out.append({&#10;                    'id_pred': r[0],&#10;                    'ts': r[1],&#10;                    'lat': r[2],&#10;                    'lon': r[3],&#10;                    'id_accidente': r[4],&#10;                    'lat_encontrada': r[5],&#10;                    'lon_encontrada': r[6],&#10;                    'riesgo_predicho': r[7],&#10;                    'probabilidad': r[8],&#10;                    'comuna': r[9],&#10;                    'ubicacion_desc': r[10],&#10;                    'causa_comun': r[11],&#10;                    'indice_severidad': r[12],&#10;                    'cliente_ip': r[13],&#10;                })&#10;            return out&#10;&#10;    def list_accidentes(&#10;        self,&#10;        comuna: Optional[str] = None,&#10;        tipo: Optional[str] = None,&#10;        gravedad_min: Optional[int] = None,&#10;        gravedad_max: Optional[int] = None,&#10;        limit: int = 200,&#10;        offset: int = 0,&#10;    ) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = (&#10;            &quot;SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, &quot;&#10;            &quot;gravedad, caus_principal, num_fallecidos, condicion_climatica FROM accidentes&quot;&#10;        )&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna_nombre)=:comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if tipo:&#10;            conds.append(&quot;UPPER(tipo_accidente)=:tipo&quot;)&#10;            params.append(tipo.upper())&#10;        if gravedad_min is not None:&#10;            conds.append(&quot;gravedad &gt;= :gmin&quot;)&#10;            params.append(int(gravedad_min))&#10;        if gravedad_max is not None:&#10;            conds.append(&quot;gravedad &lt;= :gmax&quot;)&#10;            params.append(int(gravedad_max))&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; OFFSET :offset ROWS FETCH NEXT :limit ROWS ONLY&quot;&#10;        params.extend([int(offset), int(limit)])&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            out: List[Dict[str, Any]] = []&#10;            for r in cur.fetchall():&#10;                out.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;fecha_accidente&quot;: r[1],&#10;                    &quot;hora_accidente&quot;: r[2],&#10;                    &quot;latitud&quot;: float(r[3]) if r[3] is not None else None,&#10;                    &quot;longitud&quot;: float(r[4]) if r[4] is not None else None,&#10;                    &quot;comuna_nombre&quot;: r[5],&#10;                    &quot;tipo_accidente&quot;: r[6],&#10;                    &quot;gravedad&quot;: r[7],&#10;                    &quot;caus_principal&quot;: r[8],&#10;                    &quot;num_fallecidos&quot;: r[9],&#10;                    &quot;condicion_climatica&quot;: r[10],&#10;                })&#10;            return out&#10;&#10;" />
              <option name="updatedContent" value="import os&#10;from typing import Optional, List, Dict, Any, Tuple&#10;&#10;# Nota: Importamos oracledb de forma perezosa para evitar errores si no está instalado&#10;&#10;def _import_oracledb():&#10;    try:&#10;        import oracledb  # type: ignore&#10;        return oracledb&#10;    except Exception:&#10;        try:&#10;            import cx_Oracle as oracledb  # type: ignore&#10;            return oracledb&#10;        except Exception:&#10;            return None&#10;&#10;&#10;class OracleDB:&#10;    &quot;&quot;&quot;Conector para Oracle usando python-oracledb.&#10;    Usa tabla existente 'accidentes' y crea tablas auxiliares para planes y predicciones.&#10;    &quot;&quot;&quot;&#10;    def __init__(self, user: str, password: str, dsn: str, wallet_dir: Optional[str] = None, client_lib: Optional[str] = None):&#10;        self.user = user&#10;        self.password = password&#10;        self.dsn = dsn&#10;        # Si no viene wallet_dir por env, intentamos usar ./wallet del proyecto&#10;        if not wallet_dir:&#10;            wallet_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'wallet'))&#10;            if not os.path.isdir(wallet_dir):&#10;                wallet_dir = None&#10;        self.wallet_dir = wallet_dir&#10;        self.client_lib = client_lib&#10;        # Establecer TNS_ADMIN si hay wallet&#10;        if self.wallet_dir and not os.environ.get('TNS_ADMIN'):&#10;            os.environ['TNS_ADMIN'] = self.wallet_dir&#10;        self._oracledb = _import_oracledb()&#10;        self._init_client_if_needed()&#10;&#10;    def _init_client_if_needed(self):&#10;        if self._oracledb is None:&#10;            return&#10;        try:&#10;            # Thick mode si se provee wallet/client lib&#10;            if self.wallet_dir or self.client_lib:&#10;                self._oracledb.init_oracle_client(&#10;                    lib_dir=self.client_lib if self.client_lib else None,&#10;                    config_dir=self.wallet_dir if self.wallet_dir else None,&#10;                )&#10;        except Exception as e:&#10;            print(f&quot;⚠️ No se pudo inicializar thick mode Oracle (se usará thin): {e}&quot;)&#10;&#10;    @classmethod&#10;    def from_env(cls) -&gt; Optional[&quot;OracleDB&quot;]:&#10;        user = os.environ.get(&quot;ORACLE_USER&quot;)&#10;        pwd = os.environ.get(&quot;ORACLE_PASSWORD&quot;)&#10;        dsn = os.environ.get(&quot;ORACLE_DSN&quot;)  # host:1521/servicio&#10;        wallet_dir = os.environ.get(&quot;ORACLE_WALLET_DIR&quot;)  # opcional&#10;        client_lib = os.environ.get(&quot;ORACLE_CLIENT_LIB&quot;)  # opcional ruta a instant client&#10;        if user and pwd and dsn and _import_oracledb() is not None:&#10;            return cls(user, pwd, dsn, wallet_dir=wallet_dir, client_lib=client_lib)&#10;        return None&#10;&#10;    def is_ready(self) -&gt; bool:&#10;        return self._oracledb is not None and all([self.user, self.password, self.dsn])&#10;&#10;    def connect(self):&#10;        if not self.is_ready():&#10;            raise RuntimeError(&quot;OracleDB no configurada&quot;)&#10;        oracledb = self._oracledb&#10;        # En thin mode, pasar config_dir para que tome tnsnames/ssl del wallet&#10;        try:&#10;            is_thin = getattr(oracledb, 'is_thin_mode', None)&#10;            if callable(is_thin) and is_thin() and self.wallet_dir:&#10;                return oracledb.connect(user=self.user, password=self.password, dsn=self.dsn, config_dir=self.wallet_dir)&#10;        except Exception:&#10;            pass&#10;        # Thick mode o sin wallet_dir explícito&#10;        return oracledb.connect(user=self.user, password=self.password, dsn=self.dsn)&#10;&#10;    # --- Esquema auxiliar ---&#10;    def ensure_schema(self) -&gt; None:&#10;        if not self.is_ready():&#10;            return&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            # Tabla de planes de acción&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                BEGIN&#10;                    EXECUTE IMMEDIATE 'CREATE TABLE planes_accion (&#10;                        id_plan NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,&#10;                        ts TIMESTAMP DEFAULT SYSTIMESTAMP,&#10;                        comuna VARCHAR2(200),&#10;                        ubicacion_desc VARCHAR2(1000),&#10;                        causa_comun VARCHAR2(400),&#10;                        indice_severidad NUMBER,&#10;                        titulo VARCHAR2(400),&#10;                        contenido_plan CLOB,&#10;                        fuente VARCHAR2(400)&#10;                    )';&#10;                EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;&#10;                &quot;&quot;&quot;&#10;            )&#10;            # Tabla de predicciones de riesgo&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                BEGIN&#10;                    EXECUTE IMMEDIATE 'CREATE TABLE predicciones_riesgo (&#10;                        id_pred NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,&#10;                        ts TIMESTAMP DEFAULT SYSTIMESTAMP,&#10;                        lat NUMBER,&#10;                        lon NUMBER,&#10;                        id_accidente NUMBER,&#10;                        lat_encontrada NUMBER,&#10;                        lon_encontrada NUMBER,&#10;                        riesgo_predicho VARCHAR2(100),&#10;                        probabilidad NUMBER,&#10;                        categoria_0_prob NUMBER,&#10;                        categoria_1_prob NUMBER,&#10;                        categoria_2_prob NUMBER,&#10;                        comuna VARCHAR2(200),&#10;                        ubicacion_desc VARCHAR2(1000),&#10;                        causa_comun VARCHAR2(400),&#10;                        indice_severidad NUMBER,&#10;                        cliente_ip VARCHAR2(100)&#10;                    )';&#10;                EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;&#10;                &quot;&quot;&quot;&#10;            )&#10;            con.commit()&#10;&#10;    # --- Consultas sobre tabla existente 'accidentes' ---&#10;    def list_comunas(self) -&gt; List[str]:&#10;        if not self.is_ready():&#10;            return []&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&quot;SELECT DISTINCT comuna_nombre FROM accidentes WHERE comuna_nombre IS NOT NULL&quot;)&#10;            return sorted([str(r[0]) for r in cur.fetchall() if r[0] is not None])&#10;&#10;    def fetch_points(self, comuna: Optional[str], bbox: Optional[Tuple[float, float, float, float]], limit: int = 2000) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = (&quot;SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, &quot;&#10;             &quot;gravedad, caus_principal, num_fallecidos, condicion_climatica FROM accidentes&quot;)&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna_nombre) = :comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if bbox:&#10;            min_lat, max_lat, min_lon, max_lon = bbox&#10;            conds.append(&quot;latitud BETWEEN :min_lat AND :max_lat&quot;)&#10;            conds.append(&quot;longitud BETWEEN :min_lon AND :max_lon&quot;)&#10;            params.extend([min_lat, max_lat, min_lon, max_lon])&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; FETCH FIRST :limit ROWS ONLY&quot;&#10;        params.append(int(limit))&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            rows = []&#10;            for r in cur.fetchall():&#10;                rows.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;fecha_accidente&quot;: r[1],&#10;                    &quot;hora_accidente&quot;: r[2],&#10;                    &quot;Latitude&quot;: float(r[3]),&#10;                    &quot;Longitude&quot;: float(r[4]),&#10;                    &quot;COMUNA&quot;: r[5],&#10;                    &quot;tipo_accidente&quot;: r[6],&#10;                    &quot;gravedad&quot;: r[7],&#10;                    &quot;Causa__CON&quot;: r[8],&#10;                    &quot;num_fallecidos&quot;: r[9],&#10;                    &quot;condicion_climatica&quot;: r[10],&#10;                })&#10;            return rows&#10;&#10;    def fetch_nearest_accidente(self, lat: float, lon: float) -&gt; Optional[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Busca el accidente más cercano usando distancia euclidiana simple (aprox).&quot;&quot;&quot;&#10;        if not self.is_ready():&#10;            return None&#10;        # Estrategia: limitar el set con una ventana y luego calcular distancia en Python&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;SELECT id_accidente, latitud, longitud, comuna_nombre, tipo_accidente, gravedad, caus_principal, num_fallecidos, condicion_climatica &quot;&#10;                &quot;FROM accidentes WHERE latitud BETWEEN :minlat AND :maxlat AND longitud BETWEEN :minlon AND :maxlon FETCH FIRST 1000 ROWS ONLY&quot;,&#10;                [lat - 0.2, lat + 0.2, lon - 0.2, lon + 0.2]&#10;            )&#10;            candidatos = []&#10;            for r in cur.fetchall():&#10;                candidatos.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;Latitude&quot;: float(r[1]),&#10;                    &quot;Longitude&quot;: float(r[2]),&#10;                    &quot;COMUNA&quot;: r[3],&#10;                    &quot;tipo_accidente&quot;: r[4],&#10;                    &quot;gravedad&quot;: r[5],&#10;                    &quot;Causa__CON&quot;: r[6],&#10;                    &quot;num_fallecidos&quot;: r[7],&#10;                    &quot;condicion_climatica&quot;: r[8],&#10;                })&#10;        if not candidatos:&#10;            return None&#10;        # Calcular distancia&#10;        import math&#10;        best = None&#10;        best_d = 1e12&#10;        for c in candidatos:&#10;            d = math.sqrt((c[&quot;Latitude&quot;] - lat) ** 2 + (c[&quot;Longitude&quot;] - lon) ** 2)&#10;            if d &lt; best_d:&#10;                best_d = d&#10;                best = c&#10;        return best&#10;&#10;    def stats(self, comuna: Optional[str]) -&gt; Dict[str, Any]:&#10;        if not self.is_ready():&#10;            return {&quot;total&quot;: 0, &quot;por_clase&quot;: {}, &quot;avg_severidad&quot;: None}&#10;        q = &quot;SELECT COUNT(*), AVG(gravedad) FROM accidentes&quot;&#10;        params: List[Any] = []&#10;        if comuna:&#10;            q += &quot; WHERE UPPER(comuna_nombre) = :comuna&quot;&#10;            params.append(comuna.upper())&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            row = cur.fetchone() or [0, None]&#10;            total = int(row[0] or 0)&#10;            avg_sev = float(row[1]) if row[1] is not None else None&#10;        return {&quot;total&quot;: total, &quot;por_clase&quot;: {}, &quot;avg_severidad&quot;: avg_sev}&#10;&#10;    # --- Registro de predicciones y planes ---&#10;    def log_prediction(self, record: Dict[str, Any]) -&gt; None:&#10;        if not self.is_ready():&#10;            return&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                INSERT INTO predicciones_riesgo (&#10;                    lat, lon, id_accidente, lat_encontrada, lon_encontrada, riesgo_predicho, probabilidad,&#10;                    categoria_0_prob, categoria_1_prob, categoria_2_prob, comuna, ubicacion_desc, causa_comun,&#10;                    indice_severidad, cliente_ip&#10;                ) VALUES (:lat, :lon, :id_accidente, :lat_encontrada, :lon_encontrada, :riesgo_predicho, :probabilidad,&#10;                         :categoria_0_prob, :categoria_1_prob, :categoria_2_prob, :comuna, :ubicacion_desc, :causa_comun,&#10;                         :indice_severidad, :cliente_ip)&#10;                &quot;&quot;&quot;,&#10;                record,&#10;            )&#10;            con.commit()&#10;&#10;    def save_plan(self, record: Dict[str, Any]) -&gt; None:&#10;        if not self.is_ready():&#10;            return&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;&quot;&quot;&#10;                INSERT INTO planes_accion (&#10;                    comuna, ubicacion_desc, causa_comun, indice_severidad, titulo, contenido_plan, fuente&#10;                ) VALUES (:comuna, :ubicacion_desc, :causa_comun, :indice_severidad, :titulo, :contenido_plan, :fuente)&#10;                &quot;&quot;&quot;,&#10;                record,&#10;            )&#10;            con.commit()&#10;&#10;    def list_planes(self, comuna: Optional[str], causa: Optional[str], limit: int = 100) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = &quot;SELECT id_plan, ts, comuna, ubicacion_desc, causa_comun, indice_severidad, titulo, fuente FROM planes_accion&quot;&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna)=:comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if causa:&#10;            conds.append(&quot;UPPER(causa_comun)=:causa&quot;)&#10;            params.append(causa.upper())&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; ORDER BY ts DESC FETCH FIRST :limit ROWS ONLY&quot;&#10;        params.append(int(limit))&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            out = []&#10;            for r in cur.fetchall():&#10;                out.append({&#10;                    &quot;id_plan&quot;: r[0],&#10;                    &quot;ts&quot;: r[1],&#10;                    &quot;comuna&quot;: r[2],&#10;                    &quot;ubicacion_desc&quot;: r[3],&#10;                    &quot;causa_comun&quot;: r[4],&#10;                    &quot;indice_severidad&quot;: r[5],&#10;                    &quot;titulo&quot;: r[6],&#10;                    &quot;fuente&quot;: r[7],&#10;                })&#10;            return out&#10;&#10;    def list_predicciones(self, comuna: Optional[str], limit: int = 100) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = (&quot;SELECT id_pred, ts, lat, lon, id_accidente, lat_encontrada, lon_encontrada, riesgo_predicho, probabilidad, &quot;&#10;             &quot;comuna, ubicacion_desc, causa_comun, indice_severidad, cliente_ip FROM predicciones_riesgo&quot;)&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna)=:comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; ORDER BY ts DESC FETCH FIRST :limit ROWS ONLY&quot;&#10;        params.append(int(limit))&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            out = []&#10;            for r in cur.fetchall():&#10;                out.append({&#10;                    'id_pred': r[0],&#10;                    'ts': r[1],&#10;                    'lat': r[2],&#10;                    'lon': r[3],&#10;                    'id_accidente': r[4],&#10;                    'lat_encontrada': r[5],&#10;                    'lon_encontrada': r[6],&#10;                    'riesgo_predicho': r[7],&#10;                    'probabilidad': r[8],&#10;                    'comuna': r[9],&#10;                    'ubicacion_desc': r[10],&#10;                    'causa_comun': r[11],&#10;                    'indice_severidad': r[12],&#10;                    'cliente_ip': r[13],&#10;                })&#10;            return out&#10;&#10;    def list_accidentes(&#10;        self,&#10;        comuna: Optional[str] = None,&#10;        tipo: Optional[str] = None,&#10;        gravedad_min: Optional[int] = None,&#10;        gravedad_max: Optional[int] = None,&#10;        limit: int = 200,&#10;        offset: int = 0,&#10;    ) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        q = (&#10;            &quot;SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, &quot;&#10;            &quot;gravedad, caus_principal, num_fallecidos, condicion_climatica FROM accidentes&quot;&#10;        )&#10;        conds = []&#10;        params: List[Any] = []&#10;        if comuna:&#10;            conds.append(&quot;UPPER(comuna_nombre)=:comuna&quot;)&#10;            params.append(comuna.upper())&#10;        if tipo:&#10;            conds.append(&quot;UPPER(tipo_accidente)=:tipo&quot;)&#10;            params.append(tipo.upper())&#10;        if gravedad_min is not None:&#10;            conds.append(&quot;gravedad &gt;= :gmin&quot;)&#10;            params.append(int(gravedad_min))&#10;        if gravedad_max is not None:&#10;            conds.append(&quot;gravedad &lt;= :gmax&quot;)&#10;            params.append(int(gravedad_max))&#10;        if conds:&#10;            q += &quot; WHERE &quot; + &quot; AND &quot;.join(conds)&#10;        q += &quot; OFFSET :offset ROWS FETCH NEXT :limit ROWS ONLY&quot;&#10;        params.extend([int(offset), int(limit)])&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(q, params)&#10;            out: List[Dict[str, Any]] = []&#10;            for r in cur.fetchall():&#10;                out.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;fecha_accidente&quot;: r[1],&#10;                    &quot;hora_accidente&quot;: r[2],&#10;                    &quot;latitud&quot;: float(r[3]) if r[3] is not None else None,&#10;                    &quot;longitud&quot;: float(r[4]) if r[4] is not None else None,&#10;                    &quot;comuna_nombre&quot;: r[5],&#10;                    &quot;tipo_accidente&quot;: r[6],&#10;                    &quot;gravedad&quot;: r[7],&#10;                    &quot;caus_principal&quot;: r[8],&#10;                    &quot;num_fallecidos&quot;: r[9],&#10;                    &quot;condicion_climatica&quot;: r[10],&#10;                })&#10;            return out&#10;&#10;    def list_near_accidentes(self, lat: float, lon: float, limit: int = 50, window_deg: float = 0.2) -&gt; List[Dict[str, Any]]:&#10;        if not self.is_ready():&#10;            return []&#10;        with self.connect() as con:&#10;            cur = con.cursor()&#10;            cur.execute(&#10;                &quot;SELECT id_accidente, fecha_accidente, hora_accidente, latitud, longitud, comuna_nombre, tipo_accidente, gravedad, caus_principal, num_fallecidos, condicion_climatica &quot;&#10;                &quot;FROM accidentes WHERE latitud BETWEEN :minlat AND :maxlat AND longitud BETWEEN :minlon AND :maxlon FETCH FIRST 2000 ROWS ONLY&quot;,&#10;                [lat - window_deg, lat + window_deg, lon - window_deg, lon + window_deg]&#10;            )&#10;            rows: List[Dict[str, Any]] = []&#10;            for r in cur.fetchall():&#10;                rows.append({&#10;                    &quot;id_accidente&quot;: r[0],&#10;                    &quot;fecha_accidente&quot;: r[1],&#10;                    &quot;hora_accidente&quot;: r[2],&#10;                    &quot;latitud&quot;: float(r[3]) if r[3] is not None else None,&#10;                    &quot;longitud&quot;: float(r[4]) if r[4] is not None else None,&#10;                    &quot;comuna_nombre&quot;: r[5],&#10;                    &quot;tipo_accidente&quot;: r[6],&#10;                    &quot;gravedad&quot;: r[7],&#10;                    &quot;caus_principal&quot;: r[8],&#10;                    &quot;num_fallecidos&quot;: r[9],&#10;                    &quot;condicion_climatica&quot;: r[10],&#10;                })&#10;        # Ordenar por distancia&#10;        import math&#10;        rows.sort(key=lambda x: math.sqrt(((x.get(&quot;latitud&quot;) or 0) - lat) ** 2 + ((x.get(&quot;longitud&quot;) or 0) - lon) ** 2))&#10;        return rows[: int(limit)]&#10;&#10;    def ingest_df(self, df, limit: int = 1000) -&gt; int:&#10;        &quot;&quot;&quot;Stub de ingestión deshabilitado por seguridad. Implementar solo si se requiere poblar 'accidentes'.&quot;&quot;&quot;&#10;        raise NotImplementedError(&quot;Ingest no implementado; use fuentes oficiales para poblar 'accidentes'.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/test_api.http">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/test_api.http" />
              <option name="updatedContent" value="### Root&#10;GET http://127.0.0.1:8000/&#10;&#10;### Predict (Santiago)&#10;POST http://127.0.0.1:8000/predict&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;lat&quot;: -33.45,&#10;  &quot;lon&quot;: -70.65&#10;}&#10;&#10;### Coach&#10;POST http://127.0.0.1:8000/coach&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;comuna&quot;: &quot;Santiago&quot;,&#10;  &quot;ubicacion_desc&quot;: &quot;Alameda con Ahumada&quot;,&#10;  &quot;causa_comun&quot;: &quot;IMPRUDENCIA DEL CONDUCTOR&quot;,&#10;  &quot;indice_severidad&quot;: 3&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/streamlit_app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/streamlit_app.py" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="import requests&#10;import streamlit as st&#10;import os&#10;import json&#10;import pydeck as pdk&#10;import pandas as pd&#10;from typing import Dict, Any, Optional&#10;import time&#10;&#10;API_URL = os.environ.get(&quot;API_URL&quot;, &quot;http://127.0.0.1:8000&quot;)&#10;&#10;st.set_page_config(page_title=&quot;Smart Route Optimizer&quot;, page_icon=&quot;&quot;, layout=&quot;wide&quot;)&#10;&#10;st.title(&quot; Smart Route Optimizer: Optimizador de Rutas Terrestres&quot;)&#10;&#10;st.info(&quot;Prototipo educativo del hackathon. No reemplaza evaluación profesional. Datos de ejemplo.&quot;)&#10;&#10;# Utils cache&#10;@st.cache_data(ttl=60)&#10;def api_get(url: str, params: Optional[Dict[str, Any]] = None):&#10;    r = requests.get(url, params=params, timeout=45)&#10;    r.raise_for_status()&#10;    return r.json()&#10;&#10;@st.cache_data(ttl=60)&#10;def api_post(url: str, payload: Dict[str, Any]):&#10;    r = requests.post(url, json=payload, timeout=45)&#10;    r.raise_for_status()&#10;    return r.json()&#10;&#10;# Sidebar: API and filters&#10;with st.sidebar:&#10;    st.header(&quot;Configuración&quot;)&#10;    st.write(&quot;API URL actual:&quot;)&#10;    API_URL = st.text_input(&quot;API URL&quot;, value=API_URL)&#10;    st.caption(&quot;Si cambias la URL, pulsa Enter para aplicar.&quot;)&#10;&#10;# Tabs&#10;risk_tab, map_tab, coach_tab, history_tab, export_tab = st.tabs([&#10;    &quot;1. Análisis de Riesgo (ML)&quot;,&#10;    &quot;2. Mapa y Tráfico (Geo)&quot;,&#10;    &quot;3. Coach IA y Plan de Acción (RAG)&quot;,&#10;    &quot;4. Historial (BD)&quot;,&#10;    &quot;5. Exportar y Compartir&quot;&#10;])&#10;&#10;# --- Tab 1: Predict ---&#10;with risk_tab:&#10;    st.subheader(&quot;Ingreso de Datos y Evaluación de Riesgo&quot;)&#10;    col1, col2 = st.columns([1,1])&#10;    with col1:&#10;        lat = st.number_input(&quot;Latitud&quot;, value=-33.45, step=0.001, format=&quot;%.6f&quot;)&#10;        lon = st.number_input(&quot;Longitud&quot;, value=-70.65, step=0.001, format=&quot;%.6f&quot;)&#10;        if st.button(&quot;Calcular Riesgo Vial&quot;, type=&quot;primary&quot;):&#10;            try:&#10;                data = api_post(f&quot;{API_URL}/predict&quot;, {&quot;lat&quot;: lat, &quot;lon&quot;: lon})&#10;                st.session_state[&quot;predict_result&quot;] = data&#10;            except Exception as e:&#10;                st.error(f&quot;No se pudo conectar a la API: {e}&quot;)&#10;    with col2:&#10;        if &quot;predict_result&quot; in st.session_state:&#10;            d = st.session_state[&quot;predict_result&quot;]&#10;            st.metric(&quot;Riesgo Predicho&quot;, d[&quot;riesgo_predicho&quot;], help=&quot;0: Esporádicos, 1: Comunes, 2: Muy Frecuentes&quot;)&#10;            st.progress(min(max(float(d[&quot;probabilidad&quot;]), 0.0), 1.0))&#10;            st.write(&quot;Probabilidades por clase:&quot;)&#10;            st.json({&#10;                &quot;Esporadicos&quot;: d[&quot;categoria_0_prob&quot;],&#10;                &quot;Comunes&quot;: d[&quot;categoria_1_prob&quot;],&#10;                &quot;Muy Frecuentes&quot;: d[&quot;categoria_2_prob&quot;],&#10;            })&#10;            st.write(&quot;Contexto del punto (más cercano):&quot;)&#10;            st.json({k: d[k] for k in [&quot;comuna&quot;, &quot;zona&quot;, &quot;ubicacion_desc&quot;, &quot;causa_comun&quot;, &quot;frecuencia_total&quot;, &quot;indice_severidad&quot;, &quot;lat_encontrada&quot;, &quot;lon_encontrada&quot;]})&#10;&#10;            # Mostrar accidentes cercanos en BD&#10;            st.markdown(&quot;### Accidentes Cercanos (BD)&quot;)&#10;            try:&#10;                near = api_get(f&quot;{API_URL}/near/accidentes&quot;, {&quot;lat&quot;: d[&quot;lat_encontrada&quot;], &quot;lon&quot;: d[&quot;lon_encontrada&quot;], &quot;limit&quot;: 25}).get(&quot;items&quot;, [])&#10;                st.dataframe(pd.DataFrame(near), use_container_width=True)&#10;            except Exception as e:&#10;                st.warning(f&quot;No se pudieron cargar accidentes cercanos: {e}&quot;)&#10;&#10;# --- Tab 2: Map ---&#10;with map_tab:&#10;    st.subheader(&quot;Mapa de Accidentes, Riesgo Predicho y Densidad (Heat/Hex)&quot;)&#10;&#10;    # Cargar comunas&#10;    try:&#10;        comunas = api_get(f&quot;{API_URL}/comunas&quot;).get(&quot;comunas&quot;, [])&#10;    except Exception:&#10;        comunas = []&#10;    c1, c2, c3 = st.columns([1,1,1])&#10;    with c1:&#10;        comuna_sel = st.selectbox(&quot;Filtrar por comuna (opcional)&quot;, options=[&quot;(todas)&quot;] + comunas)&#10;    with c2:&#10;        include_pred = st.checkbox(&quot;Incluir predicción por punto&quot;, value=True)&#10;    with c3:&#10;        max_points = st.slider(&quot;Máx. puntos&quot;, min_value=100, max_value=5000, value=1000, step=100)&#10;&#10;    bbox_expander = st.expander(&quot;Filtro por Bounding Box (opcional)&quot;)&#10;    with bbox_expander:&#10;        min_lat = st.number_input(&quot;min_lat&quot;, value=-33.6, step=0.01, format=&quot;%.4f&quot;)&#10;        max_lat = st.number_input(&quot;max_lat&quot;, value=-33.3, step=0.01, format=&quot;%.4f&quot;)&#10;        min_lon = st.number_input(&quot;min_lon&quot;, value=-70.8, step=0.01, format=&quot;%.4f&quot;)&#10;        max_lon = st.number_input(&quot;max_lon&quot;, value=-70.5, step=0.01, format=&quot;%.4f&quot;)&#10;        use_bbox = st.checkbox(&quot;Aplicar BBox si no hay comuna seleccionada&quot;, value=False)&#10;&#10;    params = {&quot;include_pred&quot;: 1 if include_pred else 0, &quot;limit&quot;: max_points}&#10;    if comuna_sel and comuna_sel != &quot;(todas)&quot;:&#10;        params[&quot;comuna&quot;] = comuna_sel&#10;    elif use_bbox:&#10;        params.update({&quot;min_lat&quot;: min_lat, &quot;max_lat&quot;: max_lat, &quot;min_lon&quot;: min_lon, &quot;max_lon&quot;: max_lon})&#10;&#10;    try:&#10;        fc = api_get(f&quot;{API_URL}/geo/points&quot;, params)&#10;    except Exception as e:&#10;        st.error(f&quot;No se pudo cargar puntos: {e}&quot;)&#10;        fc = {&quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: []}&#10;&#10;    feats = fc.get(&quot;features&quot;, [])&#10;    rows = []&#10;    for f in feats:&#10;        coords = f.get(&quot;geometry&quot;, {}).get(&quot;coordinates&quot;, [None, None])&#10;        prop = f.get(&quot;properties&quot;, {})&#10;        rows.append({&#10;            &quot;lon&quot;: coords[0],&#10;            &quot;lat&quot;: coords[1],&#10;            **prop,&#10;        })&#10;    df = pd.DataFrame(rows)&#10;&#10;    # Estadísticas&#10;    colA, colB, colC = st.columns(3)&#10;    try:&#10;        ss = api_get(f&quot;{API_URL}/stats&quot;, {&quot;comuna&quot;: None if comuna_sel == &quot;(todas)&quot; else comuna_sel})&#10;        colA.metric(&quot;Total puntos&quot;, ss.get(&quot;total&quot;, 0))&#10;        colB.metric(&quot;Severidad promedio&quot;, f&quot;{ss.get('avg_severidad', 0):.2f}&quot;)&#10;        colC.json(ss.get(&quot;por_clase&quot;, {}))&#10;    except Exception:&#10;        pass&#10;&#10;    # Capas toggles&#10;    st.markdown(&quot;### Capas&quot;)&#10;    lc1, lc2, lc3, lc4 = st.columns(4)&#10;    with lc1:&#10;        show_points = st.checkbox(&quot;Puntos&quot;, value=True)&#10;    with lc2:&#10;        show_heat = st.checkbox(&quot;Heatmap&quot;, value=True)&#10;    with lc3:&#10;        show_hex = st.checkbox(&quot;Hexágonos&quot;, value=False)&#10;    with lc4:&#10;        center_on_last = st.checkbox(&quot;Centrar en último análisis&quot;, value=(&quot;predict_result&quot; in st.session_state))&#10;&#10;    # Preparar colores por riesgo&#10;    def riesgo_to_color(row):&#10;        label = row.get(&quot;riesgo_predicho&quot;)&#10;        if label == &quot;Esporadicos&quot;:&#10;            return [0, 128, 255]&#10;        if label == &quot;Comunes&quot;:&#10;            return [255, 165, 0]&#10;        if label == &quot;Muy Frecuentes&quot;:&#10;            return [255, 0, 0]&#10;        # fallback según severidad&#10;        sev = float(row.get(&quot;indice_severidad&quot;, 0))&#10;        base = min(255, 80 + int(sev * 50))&#10;        return [base, 120, 120]&#10;&#10;    if not df.empty:&#10;        df[&quot;color&quot;] = df.apply(riesgo_to_color, axis=1)&#10;        # Vista inicial&#10;        if center_on_last and &quot;predict_result&quot; in st.session_state:&#10;            d = st.session_state[&quot;predict_result&quot;]&#10;            view_state = pdk.ViewState(latitude=float(d[&quot;lat_encontrada&quot;]), longitude=float(d[&quot;lon_encontrada&quot;]), zoom=13, pitch=0)&#10;        else:&#10;            view_state = pdk.ViewState(latitude=df[&quot;lat&quot;].mean(), longitude=df[&quot;lon&quot;].mean(), zoom=12, pitch=0)&#10;&#10;        layers = []&#10;        if show_heat:&#10;            layers.append(pdk.Layer(&#10;                &quot;HeatmapLayer&quot;,&#10;                data=df,&#10;                get_position='[&quot;lon&quot;, &quot;lat&quot;]',&#10;                aggregation='MEAN',&#10;                get_weight='frecuencia_total',&#10;            ))&#10;        if show_hex:&#10;            layers.append(pdk.Layer(&#10;                &quot;HexagonLayer&quot;,&#10;                data=df,&#10;                get_position='[&quot;lon&quot;, &quot;lat&quot;]',&#10;                radius=80,&#10;                elevation_scale=2,&#10;                elevation_range=[0, 1000],&#10;                extruded=True,&#10;                pickable=True,&#10;                get_elevation_weight='frecuencia_total',&#10;            ))&#10;        if show_points:&#10;            layers.append(pdk.Layer(&#10;                &quot;ScatterplotLayer&quot;,&#10;                data=df,&#10;                get_position='[&quot;lon&quot;, &quot;lat&quot;]',&#10;                get_radius=50,&#10;                get_fill_color='[color[0], color[1], color[2]]',&#10;                pickable=True,&#10;            ))&#10;&#10;        tooltip = {&quot;text&quot;: &quot;{ubicacion_desc}\n{comuna}\nRiesgo: {riesgo_predicho}\nSeveridad: {indice_severidad}\nFrecuencia: {frecuencia_total}&quot;}&#10;        rmap = pdk.Deck(layers=layers, initial_view_state=view_state, tooltip=tooltip)&#10;        st.pydeck_chart(rmap, use_container_width=True)&#10;&#10;        st.markdown(&quot;### Detalle de puntos&quot;)&#10;        st.dataframe(df.drop(columns=[&quot;lon&quot;, &quot;lat&quot;, &quot;color&quot;], errors=&quot;ignore&quot;), use_container_width=True)&#10;&#10;        # Export CSV&#10;        csv = df.to_csv(index=False).encode(&quot;utf-8&quot;)&#10;        st.download_button(&quot;Descargar datos filtrados (.csv)&quot;, data=csv, file_name=&quot;puntos_filtrados.csv&quot;, mime=&quot;text/csv&quot;)&#10;    else:&#10;        st.warning(&quot;No hay puntos para mostrar con los filtros actuales.&quot;)&#10;&#10;# --- Tab 3: Coach ---&#10;with coach_tab:&#10;    st.subheader(&quot;Plan de Acción y Sugerencias del Coach IA&quot;)&#10;    if &quot;predict_result&quot; not in st.session_state:&#10;        st.warning(&quot;Primero calcula el riesgo en la pestaña 'Análisis de Riesgo'.&quot;)&#10;    else:&#10;        d = st.session_state[&quot;predict_result&quot;]&#10;        # Selector manual de comuna (default la del análisis)&#10;        comuna_plan = st.selectbox(&quot;Comuna para el Plan&quot;, options=[d[&quot;comuna&quot;]] + list({d[&quot;comuna&quot;], *(st.session_state.get('extra_comunas', []))}), index=0)&#10;        ubicacion_desc = d[&quot;ubicacion_desc&quot;]&#10;        causa_comun = d[&quot;causa_comun&quot;]&#10;        indice_severidad = d[&quot;indice_severidad&quot;]&#10;        if st.button(&quot;Generar Plan (RAG)&quot;):&#10;            payload = {&#10;                &quot;comuna&quot;: comuna_plan,&#10;                &quot;ubicacion_desc&quot;: ubicacion_desc,&#10;                &quot;causa_comun&quot;: causa_comun,&#10;                &quot;indice_severidad&quot;: indice_severidad,&#10;            }&#10;            try:&#10;                res = api_post(f&quot;{API_URL}/coach?save=true&quot;, payload)&#10;                st.session_state[&quot;coach_result&quot;] = res&#10;            except Exception as e:&#10;                st.error(f&quot;No se pudo conectar a la API: {e}&quot;)&#10;        if &quot;coach_result&quot; in st.session_state:&#10;            c = st.session_state[&quot;coach_result&quot;]&#10;            st.subheader(c.get(&quot;titulo&quot;, &quot;Plan&quot;))&#10;            st.markdown(c.get(&quot;plan_de_accion&quot;, &quot;&quot;))&#10;            st.caption(f&quot;Fuente: {c.get('fuente', 'N/A')}&quot;)&#10;&#10;# --- Tab 4: Historial ---&#10;with history_tab:&#10;    st.subheader(&quot;Historial de Planes y Predicciones (BD)&quot;)&#10;    filt_col1, filt_col2, filt_col3 = st.columns([1,1,1])&#10;    with filt_col1:&#10;        comuna_hist = st.text_input(&quot;Filtrar por comuna (opcional)&quot;, value=&quot;&quot;)&#10;    with filt_col2:&#10;        limite = st.slider(&quot;Límite&quot;, min_value=10, max_value=500, value=100, step=10)&#10;    with filt_col3:&#10;        refrescar = st.button(&quot;Refrescar&quot;)&#10;&#10;    try:&#10;        planes = api_get(f&quot;{API_URL}/planes/list&quot;, {&quot;comuna&quot;: comuna_hist or None, &quot;limit&quot;: limite, &quot;t&quot;: time.time() if refrescar else None}).get(&quot;planes&quot;, [])&#10;    except Exception as e:&#10;        st.error(f&quot;No se pudo cargar planes: {e}&quot;)&#10;        planes = []&#10;    try:&#10;        preds = api_get(f&quot;{API_URL}/predicciones/list&quot;, {&quot;comuna&quot;: comuna_hist or None, &quot;limit&quot;: limite, &quot;t&quot;: time.time() if refrescar else None}).get(&quot;predicciones&quot;, [])&#10;    except Exception as e:&#10;        st.error(f&quot;No se pudo cargar predicciones: {e}&quot;)&#10;        preds = []&#10;&#10;    cA, cB = st.columns(2)&#10;    with cA:&#10;        st.markdown(&quot;### Planes de Acción Guardados&quot;)&#10;        st.dataframe(pd.DataFrame(planes), use_container_width=True)&#10;    with cB:&#10;        st.markdown(&quot;### Predicciones Recientes&quot;)&#10;        st.dataframe(pd.DataFrame(preds), use_container_width=True)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    st.subheader(&quot;Datos de Accidentes en BD y Scoring del Modelo&quot;)&#10;    fa1, fa2, fa3, fa4, fa5 = st.columns([1,1,1,1,1])&#10;    with fa1:&#10;        comuna_f = st.text_input(&quot;Comuna (opcional)&quot;, value=&quot;&quot;)&#10;    with fa2:&#10;        tipo_f = st.text_input(&quot;Tipo de accidente (opcional)&quot;, value=&quot;&quot;)&#10;    with fa3:&#10;        gmin = st.number_input(&quot;Gravedad min (opcional)&quot;, value=0, step=1)&#10;    with fa4:&#10;        gmax = st.number_input(&quot;Gravedad max (opcional)&quot;, value=10, step=1)&#10;    with fa5:&#10;        lim = st.slider(&quot;Límite filas&quot;, min_value=10, max_value=2000, value=200, step=10)&#10;&#10;    b1, b2 = st.columns([1,1])&#10;    with b1:&#10;        if st.button(&quot;Cargar Accidentes BD&quot;):&#10;            try:&#10;                params = {&#10;                    &quot;comuna&quot;: (comuna_f or None),&#10;                    &quot;tipo&quot;: (tipo_f or None),&#10;                    &quot;gravedad_min&quot;: int(gmin) if gmin is not None else None,&#10;                    &quot;gravedad_max&quot;: int(gmax) if gmax is not None else None,&#10;                    &quot;limit&quot;: int(lim),&#10;                }&#10;                data = api_get(f&quot;{API_URL}/accidentes&quot;, params).get(&quot;accidentes&quot;, [])&#10;                st.session_state[&quot;accidentes_raw&quot;] = pd.DataFrame(data)&#10;            except Exception as e:&#10;                st.error(f&quot;Error al cargar accidentes: {e}&quot;)&#10;    with b2:&#10;        if st.button(&quot;Calcular Score en Accidentes&quot;):&#10;            try:&#10;                params = {&#10;                    &quot;comuna&quot;: (comuna_f or None),&#10;                    &quot;tipo&quot;: (tipo_f or None),&#10;                    &quot;gravedad_min&quot;: int(gmin) if gmin is not None else None,&#10;                    &quot;gravedad_max&quot;: int(gmax) if gmax is not None else None,&#10;                    &quot;limit&quot;: int(lim),&#10;                }&#10;                items = api_get(f&quot;{API_URL}/score/accidentes&quot;, params).get(&quot;items&quot;, [])&#10;                st.session_state[&quot;accidentes_score&quot;] = pd.DataFrame(items)&#10;            except Exception as e:&#10;                st.error(f&quot;Error al calcular score: {e}&quot;)&#10;&#10;    if &quot;accidentes_raw&quot; in st.session_state:&#10;        st.markdown(&quot;### Accidentes (BD)&quot;)&#10;        df_raw = st.session_state[&quot;accidentes_raw&quot;]&#10;        st.dataframe(df_raw, use_container_width=True)&#10;        st.download_button(&quot;Descargar Accidentes (.csv)&quot;, data=df_raw.to_csv(index=False).encode(&quot;utf-8&quot;), file_name=&quot;accidentes_bd.csv&quot;, mime=&quot;text/csv&quot;)&#10;&#10;    if &quot;accidentes_score&quot; in st.session_state:&#10;        st.markdown(&quot;### Accidentes con Predicción del Modelo&quot;)&#10;        df_sc = st.session_state[&quot;accidentes_score&quot;]&#10;        st.dataframe(df_sc, use_container_width=True)&#10;        st.download_button(&quot;Descargar Scoring (.csv)&quot;, data=df_sc.to_csv(index=False).encode(&quot;utf-8&quot;), file_name=&quot;accidentes_scoring.csv&quot;, mime=&quot;text/csv&quot;)&#10;&#10;# --- Tab 5: Export ---&#10;with export_tab:&#10;    st.subheader(&quot;Descargar Plan y Compartir&quot;)&#10;    if &quot;coach_result&quot; in st.session_state:&#10;        import io&#10;        from datetime import datetime, timezone&#10;        c = st.session_state[&quot;coach_result&quot;]&#10;        contenido = &quot;\n&quot;.join([&#10;            f&quot;Plan generado: {c.get('titulo','')}&quot;,&#10;            &quot;&quot;,&#10;            c.get('plan_de_accion', ''),&#10;            &quot;&quot;,&#10;            f&quot;Fuente: {c.get('fuente','N/A')}&quot;,&#10;            f&quot;Generado: {datetime.now(timezone.utc).isoformat()}&quot;&#10;        ])&#10;        b = io.BytesIO(contenido.encode(&quot;utf-8&quot;))&#10;        st.download_button(&quot;Descargar Plan (.txt)&quot;, b, file_name=&quot;plan_optimizador.txt&quot;, mime=&quot;text/plain&quot;)&#10;    else:&#10;        st.info(&quot;Genere el plan primero en la pestaña 3.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/datos/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/datos/README.md" />
              <option name="updatedContent" value="Coloque aquí:&#10;- motor_riesgo.joblib (modelo entrenado)&#10;- Siniestros_Maestro_Consolidado_Hackathon.csv (dataset maestro)&#10;&#10;Si estos archivos no están presentes, la API usará datos sintéticos para demo.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/kb/fichas.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/kb/fichas.md" />
              <option name="updatedContent" value="# CAUSA: IMPRUDENCIA DEL CONDUCTOR&#10;*Riesgo Identificado:* La causa más común es la conducción no atenta a las condiciones del tránsito, exceso de velocidad o imprudencia general.&#10;*Plan de Acción Sugerido:*&#10;* Instalación de reductores de velocidad (lomos de toro) o resaltos peatonales para forzar la reducción de velocidad.&#10;* Aumentar la fiscalización de velocidad (Carabineros) o evaluar la instalación de cámaras de control.&#10;* Mejorar la señalética de &quot;Velocidad Máxima Permitida&quot; y &quot;Zona de Alta Siniestralidad&quot;.&#10;*Fuente:* Manual de Seguridad Vial CONASET, Cap. 2.&#10;&#10;# CAUSA: DESOBEDIENCIA A SEÑALIZACION&#10;*Riesgo Identificado:* Los conductores no están respetando las señales de &quot;PARE&quot;, &quot;CEDA EL PASO&quot; o la luz roja del semáforo.&#10;*Plan de Acción Sugerido:*&#10;* Revisar la visibilidad de la señalética (despejar ramas, limpiar señales, asegurar correcta angulación).&#10;* Evaluar la implementación de &quot;tercer tiempo&quot; en semáforos para evitar colisiones en luz roja.&#10;* Instalar balizas o &quot;semáforos de advertencia&quot; (luz amarilla intermitente) previos al cruce para aumentar la alerta.&#10;*Fuente:* Observatorio de Ciudades UC, 2024.&#10;&#10;# CAUSA: IMPRUDENCIA DEL PEATON&#10;*Riesgo Identificado:* Alta incidencia de atropellos donde el peatón cruza por zonas no habilitadas o de forma descuidada.&#10;*Plan de Acción Sugerido:*&#10;* Instalación de vallas peatonales (canalizadores) para guiar el cruce hacia la esquina habilitada.&#10;* Mejorar la iluminación del paso de cebra (iluminación cenital).&#10;* Demarcar y pintar nuevamente el paso de cebra con pintura de alto contraste.&#10;*Fuente:* Guía de Diseño Urbano y Accesibilidad, Minvu.&#10;&#10;# CAUSA: ALCOHOL EN CONDUCTOR&#10;*Riesgo Identificado:* Punto crítico de siniestros asociados al consumo de alcohol.&#10;*Plan de Acción Sugerido:*&#10;* Coordinar con SENDA y Carabineros para aumentar la fiscalización aleatoria (Operación Tolerancia Cero) en este punto, especialmente en horarios nocturnos y fines de semana.&#10;* Instalar señalética de alto impacto sobre las penas legales de la conducción con alcohol (Ley Emilia).&#10;*Fuente:* Plan Nacional de Seguridad Vial, 2024.&#10;&#10;# CAUSA: CALZADA RESBALADIZA&#10;*Riesgo Identificado:* El estado de la vía (ej. &quot;calzada resbaladiza&quot; por aceite o desgaste) es un factor determinante.&#10;*Plan de Acción Sugerido:*&#10;* Estudio de ingeniería para repavimentación de la calzada con material de alta adherencia (pavimento rugoso).&#10;* Mejorar el sistema de evacuación de aguas lluvia para evitar pozas.&#10;* Instalar señalética de advertencia &quot;Peligro: Pavimento Resbaladizo&quot;.&#10;*Fuente:* Manual de Carreteras, MOP.&#10;&#10;# CAUSA: OTRO&#10;*Riesgo Identificado:* Causa no especificada, indeterminada o múltiple.&#10;*Plan de Acción Sugerido:*&#10;* Se requiere un estudio de ingeniería en terreno para determinar la causa raíz.&#10;* Como acción inmediata: Aumentar la iluminación general del punto y la señalética de &quot;Zona de Accidentes&quot;.&#10;*Fuente:* Protocolo de Análisis de Puntos Críticos.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI&#10;&#10;app = FastAPI()&#10;&#10;&#10;@app.get(&quot;/&quot;)&#10;async def root():&#10;    return {&quot;message&quot;: &quot;Hello World&quot;}&#10;&#10;&#10;@app.get(&quot;/hello/{name}&quot;)&#10;async def say_hello(name: str):&#10;    return {&quot;message&quot;: f&quot;Hello {name}&quot;}&#10;" />
              <option name="updatedContent" value="from fastapi import FastAPI&#10;import os&#10;import sys&#10;&#10;app = FastAPI()&#10;&#10;&#10;@app.get(&quot;/&quot;)&#10;async def root():&#10;    return {&quot;message&quot;: &quot;Hello World&quot;}&#10;&#10;&#10;@app.get(&quot;/hello/{name}&quot;)&#10;async def say_hello(name: str):&#10;    return {&quot;message&quot;: f&quot;Hello {name}&quot;}&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Permite ejecutar: python main.py api|app&#10;    mode = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;api&quot;&#10;    if mode == &quot;api&quot;:&#10;        # Arranca FastAPI con uvicorn&#10;        os.system(&quot;uvicorn api.main:app --host 0.0.0.0 --port 8000&quot;)&#10;    elif mode == &quot;app&quot;:&#10;        # Arranca Streamlit&#10;        os.environ.setdefault(&quot;API_URL&quot;, &quot;http://127.0.0.1:8000&quot;)&#10;        os.system(&quot;streamlit run app/streamlit_app.py --server.port 8501&quot;)&#10;    else:&#10;        print(&quot;Uso: python main.py [api|app]&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="fastapi&#10;uvicorn[standard]&#10;scikit-learn&#10;xgboost&#10;joblib&#10;pandas&#10;numpy&#10;imbalanced-learn&#10;streamlit&#10;requests&#10;pydeck&#10;# python-oracledb  # opcional; si no funciona en tu entorno, usa cx_Oracle&#10;cx_Oracle&#10;# geopandas  # opcional, solo si necesitas cruces espaciales avanzados" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>